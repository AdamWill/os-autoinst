#!/usr/bin/perl -w
# Copyright © 2009-2013 Bernhard M. Wiedemann
# Copyright © 2012-2016 SUSE LLC
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <http://www.gnu.org/licenses/>.
#

use strict;

local $Devel::Trace::TRACE;
$Devel::Trace::TRACE = 0;

my $installprefix;    # $bmwqemu::scriptdir

BEGIN {
    # the following line is modified during make install
    $installprefix = undef;

    my ($wd) = $0 =~ m-(.*)/-;
    $wd ||= '.';
    $installprefix ||= $wd;
    unshift @INC, "$installprefix";
}

use bmwqemu;
use needle;
use autotest;
use commands;
use testapi qw(diag);
use Getopt::Std;
require IPC::System::Simple;
use autodie qw(:all);
use POSIX qw(:sys_wait_h _exit);
use Carp qw(cluck);
use Time::HiRes qw(gettimeofday tv_interval sleep);

# avoid paranoia
$Getopt::Std::STANDARD_HELP_VERSION = 1;

sub HELP_MESSAGE {
    print "$0 [-d]\n";
    print "Parses vars.json and tests the given assets/ISOS\n\n";
    print " -d enables direct output to STDERR instead of autoinst-log.txt\n";
}

# enable debug default when started from a tty
$bmwqemu::istty = -t 1;    ## no critic
our ($opt_d);
getopts('d');
$bmwqemu::direct_output = $opt_d;

select(STDERR);
$| = 1;
select(STDOUT);            # default
$| = 1;

$bmwqemu::scriptdir = $installprefix;
bmwqemu::init();

# Sanity checks
die "CASEDIR environment variable not set, unknown test case directory" if !defined $bmwqemu::vars{CASEDIR};
die "No scripts in $bmwqemu::vars{CASEDIR}" if !-e "$bmwqemu::vars{CASEDIR}";

my $cpid;
my $cfd;

# all so ugly ...
sub signalhandler {

    my ($sig) = @_;
    diag("$$: signalhandler got $sig");
    if ($autotest::running) {
        $autotest::running->fail_if_running();
        $autotest::running = undef;
    }
    if (defined $bmwqemu::backend && $bmwqemu::backend->{backend_pid}) {
        diag("$$: killing backend process $bmwqemu::backend->{backend_pid}");
        kill('SIGTERM', $bmwqemu::backend->{backend_pid});
        waitpid($bmwqemu::backend->{backend_pid}, 0);
        diag("$$: done with backend process");
        $bmwqemu::backend->{backend_pid} = 0;
    }
    # make sure the currently running test is shown as failed
    if (my $test = bmwqemu::current_test()) {
        $test->fail_if_running();
        $test->save_test_result();
    }
    if (defined $cpid) {
        diag("$$: killing commands process $cpid");
        kill('SIGTERM', $cpid);
        waitpid($cpid, 0);
        diag("$$: done joining commands process");
        $cpid = 0;
    }
    _exit(1);
}

sub signalhandler_chld {

    diag("$$: got sigchld");

    while ((my $child = waitpid(-1, WNOHANG)) > 0) {
        if ($child == $cpid) {
            diag("$$: commands webserver died");
            $cpid = 0;
        }
        if ($bmwqemu::backend->{backend_pid} && $child == $bmwqemu::backend->{backend_pid}) {
            diag("$$: backend $child died");
            $bmwqemu::backend->{backend_pid} = 0;
            $bmwqemu::backend->{to_child}    = undef;
            $bmwqemu::backend->{from_child}  = undef;
        }
    }
}

sub init_backend {
    my ($name) = @_;
    $bmwqemu::vars{BACKEND} ||= "qemu";
    # make sure the needles are initialized before the backend process is started
    needle::init($bmwqemu::vars{PRODUCTDIR} . "/needles");
    $bmwqemu::backend = backend::driver->new($bmwqemu::vars{BACKEND});
    return $bmwqemu::backend;
}

my $current_test_name;
sub save_status {
    my $result = {};
    $result->{interactive} = 0;
    $result->{needinput}   = 0;
    $result->{running}     = $current_test_name;
    cluck "save_status\n";
    $result->{backend} = $bmwqemu::backend->get_info() if $bmwqemu::backend;
    diag "got info";
    return bmwqemu::save_json_file($result, bmwqemu::result_dir . "/status.json");
}

$SIG{ALRM} = \&signalhandler;
$SIG{TERM} = \&signalhandler;
$SIG{INT}  = \&signalhandler;
$SIG{HUP}  = \&signalhandler;
$SIG{CHLD} = \&signalhandler_chld;

# start the command fork before we get into the backend, the command child
# is not supposed to talk to the backend directly
($cpid, $cfd) = commands::start_server($bmwqemu::vars{QEMUPORT} + 1);

# Try to load the main.pm from one of the following in this order:
#  - product dir
#  - casedir
#
# This allows further structuring the test distribution collections with
# multiple distributions or flavors in one repository.
$bmwqemu::vars{PRODUCTDIR} ||= $bmwqemu::vars{CASEDIR};
require $bmwqemu::vars{PRODUCTDIR} . "/main.pm";

# set a default distribution if the tests don't have one
$testapi::distri ||= distribution->new;

testapi::init();

use Data::Dumper;
print Dumper($testapi::distri);

# init part
bmwqemu::save_vars();

my ($testpid, $testfd) = autotest::start_process();

init_backend();

open(my $fd, ">", "os-autoinst.pid");
print $fd "$$\n";
close $fd;

if (!$bmwqemu::backend->_send_json({cmd => 'alive'})) {
    $bmwqemu::backend->start_vm() or die $@;
}

# the backend process might have added some defaults for the backend
bmwqemu::load_vars();

if ($ENV{RUN_VNCVIEWER}) {
    system("vncviewer -shared localhost:" . $bmwqemu::vars{VNC} . " -viewonly &");
}
if ($ENV{RUN_DEBUGVIEWER}) {
    system("$bmwqemu::scriptdir/debugviewer/debugviewer qemuscreenshot/last.png &");
}

use IO::Select;

my $s = IO::Select->new();
$s->add($testfd);
$s->add($cfd);

# now we have everything, give the tests a go
$testfd->write("GO\n");

my $loop    = 1;
my $timeout = undef;
my $tags    = undef;
while ($loop) {
    my ($reads, $writes, $exceps) = IO::Select::select($s, undef, $s, $timeout);
    for my $r (@$reads) {
        my $rsp = myjsonrpc::read_json($r);
        if (!defined $rsp) {
            diag sprintf("THERE IS NOTHING TO READ %d %d %d", fileno($r), fileno($testfd), fileno($cfd));
            $loop = 0;
            last;
        }
        if ($rsp->{cmd} =~ m/^backend_(.*)/) {
            my $cmd = $1;
            delete $rsp->{cmd};
            my $brsp = $bmwqemu::backend->_send_json({cmd => $cmd, arguments => $rsp});
            myjsonrpc::send_json($r, {ret => $brsp});
            next;
        }
        if ($rsp->{cmd} eq 'set_current_test') {
            $bmwqemu::backend->_send_json({cmd => 'set_serial_offset'});
            $current_test_name = $rsp->{name};
            save_status;
            myjsonrpc::send_json($r, {ret => 1});
            next;
        }

        if ($rsp->{cmd} eq 'check_screen') {
            my $mustmatch = $rsp->{mustmatch};
            my $timeout   = $rsp->{timeout};
            my $check     = $rsp->{check};

            $tags = $bmwqemu::backend->_send_json(
                {
                    cmd       => 'set_tags_to_assert',
                    arguments => {
                        mustmatch => $mustmatch,
                        timeout   => $timeout
                    }})->{tags};
            next;
        }
        die "Unknown command $rsp->{cmd}";
    }

    if (defined $tags) {
        my ($seconds, $microseconds) = gettimeofday;
        my $rsp = $bmwqemu::backend->_send_json({cmd => 'check_asserted_screen'});
        # the test needs that information
        $rsp->{tags} = $tags;
        if ($rsp->{found}) {
            myjsonrpc::send_json($testfd, {ret => $rsp});
            $tags = $timeout = undef;
        }
        elsif ($rsp->{timeout}) {
            myjsonrpc::send_json($testfd, {ret => $rsp});
            $tags = $timeout = undef;
        }
        else {
            my $delta = tv_interval([$seconds, $microseconds], [gettimeofday]);
            if ($delta > 0) {
                # sleep the remains of one second
                $timeout = 1 - $delta;
            }
            else {
                $timeout = 0;
            }
        }
    }
}
close $testfd;
kill('SIGTERM', $testpid);
diag "awaiting death of testpid $testpid";
waitpid($testpid, 0);

my $r = 0;
diag "isotovideo done" unless $r;
diag "FAIL" if $r;

my $clean_shutdown;
eval {
    my $status = $bmwqemu::backend->status();
    $clean_shutdown = 1 if $status || '' eq "shutdown";
};

bmwqemu::stop_vm();
diag "killing commands process";
if ($cpid) {
    kill('SIGTERM', $cpid);
    waitpid($cpid, 0);
}
diag "done joining commands process";

# mark hard disks for upload if test finished
if (!$r && (my $nd = $bmwqemu::vars{NUMDISKS})) {
    # if status() died the backend was already dead. So some fatal test
    # probably took it down. Don't upload in that case.
    my @toextract;
    for my $i (1 .. $nd) {
        my $dir = 'assets_private';
        my $name = $bmwqemu::vars{"STORE_HDD_$i"} || undef;
        unless ($name) {
            $name = $bmwqemu::vars{"PUBLISH_HDD_$i"} || undef;
            $dir = 'assets_public';
        }
        next unless $name;
        $name =~ /\.([[:alnum:]]+)$/;
        my $format = $1;
        push @toextract, {hdd_num => $i, name => $name, dir => $dir, format => $format};
    }
    if (@toextract && !$clean_shutdown) {
        diag "ERROR: Machine not shut down when uploading disks!\n";
    }
    else {
        for my $asset (@toextract) {
            $bmwqemu::backend->extract_assets($asset);
        }
    }
}

# Write JSON result
save_status();

exit $r;
# vim: set sw=4 et:
