#!/usr/bin/perl -w
# Copyright © 2009-2013 Bernhard M. Wiedemann
# Copyright © 2012-2016 SUSE LLC
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <http://www.gnu.org/licenses/>.
#

use strict;

local $Devel::Trace::TRACE;
$Devel::Trace::TRACE = 0;

my $installprefix;    # $bmwqemu::scriptdir

BEGIN {
    # the following line is modified during make install
    $installprefix = undef;

    my ($wd) = $0 =~ m-(.*)/-;
    $wd ||= '.';
    $installprefix ||= $wd;
    unshift @INC, "$installprefix";
}

use bmwqemu;
use needle;
use autotest;
use testapi qw(diag);
use Getopt::Std;
require IPC::System::Simple;
use autodie qw(:all);
use Cwd;
use POSIX qw(:sys_wait_h _exit);

# avoid paranoia
$Getopt::Std::STANDARD_HELP_VERSION = 1;

sub HELP_MESSAGE {
    print "$0 [-d]\n";
    print "Parses vars.json and tests the given assets/ISOS\n\n";
    print " -d enables direct output to STDERR instead of autoinst-log.txt\n";
}

# enable debug default when started from a tty
$bmwqemu::istty = -t 1;    ## no critic
our ($opt_d);
getopts('d');
$bmwqemu::direct_output = $opt_d;

select(STDERR);
$| = 1;
select(STDOUT);            # default
$| = 1;

$bmwqemu::scriptdir = $installprefix;
bmwqemu::init();

# Sanity checks
die "CASEDIR environment variable not set, unknown test case directory" if !defined $bmwqemu::vars{CASEDIR};
die "No scripts in $bmwqemu::vars{CASEDIR}" if !-e "$bmwqemu::vars{CASEDIR}";

bmwqemu::clean_control_files();

my $init = 1;

my $cpid;
my $backend;

# all so ugly ...
sub signalhandler {

    my ($sig) = @_;
    diag("$$: signalhandler got $sig");
    if ($autotest::running) {
        $autotest::running->fail_if_running();
        $autotest::running = undef;
    }
    if (defined $backend && $backend->{backend_pid}) {
        diag("$$: killing backend process $backend->{backend_pid}");
        kill('SIGTERM', $backend->{backend_pid});
        waitpid($backend->{backend_pid}, 0);
        diag("$$: done with backend process");
        $backend->{backend_pid} = 0;
    }
    # mark it as no longer working
    delete $ENV{WORKERID};
    bmwqemu::save_status();
    # make sure the currently running test is shown as failed
    if (my $test = bmwqemu::current_test()) {
        $test->fail_if_running();
        $test->save_test_result();
    }
    if (defined $cpid) {
        diag("$$: killing commands process $cpid");
        kill('SIGTERM', $cpid);
        waitpid($cpid, 0);
        diag("$$: done joining commands process");
        $cpid = 0;
    }
    _exit(1);
}

sub signalhandler_chld {

    diag("$$: got sigchld");

    while ((my $child = waitpid(-1, WNOHANG)) > 0) {
        if ($child == $cpid) {
            diag("$$: commands webserver died");
            $cpid = 0;
        }
        else {
            diag("$$: backend $child died");
            $backend->{backend_pid} = 0;
            $backend->{to_child}    = undef;
            $backend->{from_child}  = undef;
        }
    }
}

$ENV{MOJO_MAX_MESSAGE_SIZE} = 107741824;

# start web background server that provides real time information
# about the ongoing run
use commands;

$bmwqemu::vars{BACKEND} ||= "qemu";

# Try to load the main.pm from one of the following in this order:
#  - product dir
#  - casedir
#
# This allows further structuring the test distribution collections with
# multiple distributions or flavors in one repository.
$bmwqemu::vars{PRODUCTDIR} ||= $bmwqemu::vars{CASEDIR};

# as we are about to load the test modules store the git hash that has been
# used. If it is not a git repo fail silently, i.e. store an empty variable

my $dir = getcwd;
chdir($bmwqemu::vars{CASEDIR});
chomp(my $test_git_hash = qx{git rev-parse HEAD});
$test_git_hash ||= "UNKNOWN";
chdir($dir);
diag "git hash of test distribution: $test_git_hash";
# TODO find a better place to store hash in than vars.json, see
# https://github.com/os-autoinst/os-autoinst/pull/393#discussion_r50143013
$bmwqemu::vars{TEST_GIT_HASH} = $test_git_hash;

require $bmwqemu::vars{PRODUCTDIR} . "/main.pm";

# set a default distribution if the tests don't have one
$testapi::distri ||= distribution->new;

# start the command fork before we get into the backend, the command child
# is not supposed to talk to the backend directly
$cpid = commands::start_server($bmwqemu::vars{QEMUPORT} + 1);

# init part
bmwqemu::save_vars();
# make sure the needles are initialized before the backend thread is started
needle::init($bmwqemu::vars{PRODUCTDIR} . "/needles");
$backend = bmwqemu::init_backend($bmwqemu::vars{BACKEND});

if ($init) {
    open(my $fd, ">", "os-autoinst.pid");
    print $fd "$$\n";
    close $fd;

    # run prestart test code before VM is started
    if (-f "$bmwqemu::vars{CASEDIR}/prestart.pm") {
        diag "running prestart step";
        eval { require $bmwqemu::vars{CASEDIR} . "/prestart.pm"; };
        if ($@) {
            diag "prestart step FAIL:";
            die $@;
        }
    }

    if (!bmwqemu::alive) {
        bmwqemu::start_vm or die $@;
    }
}

$SIG{ALRM} = \&signalhandler;
$SIG{TERM} = \&signalhandler;
$SIG{INT}  = \&signalhandler;
$SIG{HUP}  = \&signalhandler;
$SIG{CHLD} = \&signalhandler_chld;

if ($ENV{RUN_VNCVIEWER}) {
    system("vncviewer -shared localhost:" . $bmwqemu::vars{VNC} . " -viewonly &");
}
if ($ENV{RUN_DEBUGVIEWER}) {
    system("$bmwqemu::scriptdir/debugviewer/debugviewer qemuscreenshot/last.png &");
}

require Carp;

my $r = 0;
eval { autotest::runalltests(); };
if ($@) {
    warn $@;
    $r = 1;
}
else {
    # this is only for still getting screenshots while
    # all testscripts would have been already run
    sleep 10;
}

diag "isotovideo done" unless $r;
diag "FAIL" if $r;

$SIG{ALRM} = 'IGNORE';    # ignore ALRM so the readthread doesn't kill us here

my $clean_shutdown;
eval {
    my $status = $bmwqemu::backend->status();
    $clean_shutdown = 1 if $status || '' eq "shutdown";
};

bmwqemu::stop_vm();
diag "killing commands process";
if ($cpid) {
    kill('SIGTERM', $cpid);
    waitpid($cpid, 0);
}
diag "done joining commands process";

# mark hard disks for upload if test finished
if (!$r && (my $nd = $bmwqemu::vars{NUMDISKS})) {
    # if status() died the backend was already dead. So some fatal test
    # probably took it down. Don't upload in that case.
    my @toextract;
    for my $i (1 .. $nd) {
        my $dir = 'assets_private';
        my $name = $bmwqemu::vars{"STORE_HDD_$i"} || undef;
        unless ($name) {
            $name = $bmwqemu::vars{"PUBLISH_HDD_$i"} || undef;
            $dir = 'assets_public';
        }
        next unless $name;
        $name =~ /\.([[:alnum:]]+)$/;
        my $format = $1;
        push @toextract, {hdd_num => $i, name => $name, dir => $dir, format => $format};
    }
    if (@toextract && !$clean_shutdown) {
        diag "ERROR: Machine not shut down when uploading disks!\n";
    }
    else {
        for my $asset (@toextract) {
            $bmwqemu::backend->extract_assets($asset);
        }
    }
}

# run postrun test code after VM is stopped
if (-f "$bmwqemu::vars{CASEDIR}/postrun.pm") {
    diag "running postrun step";
    eval { require "$bmwqemu::vars{CASEDIR}/postrun.pm"; };    ## no critic
    if ($@) {
        diag "postrun step FAIL:";
        warn $@;
    }
}

# mark it as no longer working
delete $ENV{WORKERID};

# Write JSON result
bmwqemu::save_status();

exit $r;
# vim: set sw=4 et:
